### В цілому все починається з реєстрації. Під час реєстрації користувача автоматично створюється штрихкод.

#### Опис:
Ендпоінт для реєстрації користувача. Перевіряє унікальність email та телефонного номера, генерує унікальний штрих-код і зберігає користувача в базі даних.

#### Метод:
`POST /register`

#### Параметри:
- **user (UserCreate)**: Дані користувача для реєстрації:
  - `email`, `password`, `full_name`, `phone`, `role`
  
- **db (db_dependency)**: Доступ до бази даних.

#### Логіка:
1. Перевіряється, чи існують користувачі з таким `email` або `phone`. Якщо так — повертається помилка 400.
2. Генерується `barcode_id` та шлях до штрих-коду.
3. Створюється новий користувач з хешованим паролем.
4. Користувач додається в базу даних.

#### Відповідь:
- **Успіх**:
  ```json
  {
    "message": "Користувач був успішно зареєстрований"
  }
  ```
- **Помилки (HTTP 400)**:
  - Якщо email вже зареєстрований:
  ```json
  {
    "detail": "Email already registered"
  }
  ```
  - Якщо телефон вже зареєстрований:
  ```json
  {
    "detail": "Phone already registered"
  }
  ```

#### Приклад запиту:
```bash
POST /register
Content-Type: application/json

{
  "email": "user1@example.com",
  "password": "SecurePassword123",
  "full_name": "John Doe",
  "phone": "1234567890",
  "role": "user"
}
```
### Далі має відбуватись логін користувача

#### Опис:
Ендпоінт для автентифікації користувача за допомогою email та пароля. Після успішної автентифікації генерується токен доступу.

#### Метод:
`POST /login`

#### Параметри:
- **form_data (UserLoginModel)**: Дані для входу:
  - `email`: Email користувача.
  - `password`: Пароль користувача.

- **db (db_dependency)**: Доступ до бази даних.

#### Логіка:
1. Автентифікація користувача за допомогою функції `authenticate_user()`, яка перевіряє правильність email і пароля.
2. Якщо користувач не знайдений або пароль неправильний, викидається помилка HTTP 401.
3. Якщо автентифікація успішна, генерується токен доступу за допомогою `create_access_token()`.
4. Повертається токен доступу у форматі `bearer`.

#### Відповідь:
- **Успіх**:
  ```json
  {
    "access_token": "токен_доступу",
    "token_type": "bearer"
  }
  ```
- **Помилка (HTTP 401)**:
  - Якщо автентифікація не вдалася:
  ```json
  {
    "detail": "Could not validate user"
  }
  ```

#### Приклад запиту:
```bash
POST /login
Content-Type: application/json

{
  "email": "user1@example.com",
  "password": "SecurePassword123"
}
```


### Документація до функцій після логування користувача

#### 1. **Створення посилки**
   - **Метод**: `POST /`
   - **Опис**: Створює нову посилку для користувача. Користувач може відправити посилку іншому отримувачу, вказавши пункти відправлення та отримання, вагу, розміри та інші параметри.
   - **Параметри**:
     - `shipment_data` (тип `ShipmentCreate`): Дані для створення посилки.
   - **Перевірки**:
     - Перевірка, чи користувач автентифікований.
     - Перевірка наявності отримувача, відправлення та отримання у відповідних філіях.
     - Перевірка, чи не намагається користувач відправити посилку собі.
   - **Відповідь**:
     - Успіх: `{"message": "Посилка створена", "tracking_number": "трекинговий_номер"}`
     - Помилки: HTTP 401, 404, 400 (з відповідними повідомленнями).

#### 2. **Розрахунок вартості посилки**
   - **Метод**: `POST /shipment/calculate_price`
   - **Опис**: Обчислює вартість доставки між двома філіями на основі ваги та розмірів посилки.
   - **Параметри**:
     - `data` (тип `ShipmentCalculate`): Дані для розрахунку.
   - **Відповідь**:
     - Успіх: `{"distance_km": 100, "price": 500}`
     - Помилки: HTTP 404 (якщо одна з філій не знайдена).

#### 3. **Отримання посилок користувача**
   - **Метод**: `GET /my-shipments`
   - **Опис**: Повертає список усіх посилок користувача як відправника чи отримувача.
   - **Перевірки**:
     - Перевірка, чи користувач автентифікований.
   - **Відповідь**:
     - Успіх: список посилок у форматі JSON.

#### 4. **Отримання посилки за трек-номером**
   - **Метод**: `GET /{tracking_number}`
   - **Опис**: Повертає деталі посилки за вказаним трек-номером.
   - **Перевірки**:
     - Перевірка, чи існує посилка з таким трек-номером.
   - **Відповідь**:
     - Успіх: інформація про посилку.
     - Помилка 404: "Замовлення не знайдено".

#### 5. **Зміна статусу посилки**
   - **Метод**: `PUT /change_status/{tracking_number}`
   - **Опис**: Змінює статус посилки (тільки для адміністраторів та кур'єрів).
   - **Перевірки**:
     - Перевірка, чи користувач має відповідні права (адміністратор чи кур'єр).
     - Перевірка наявності валідного статусу.
   - **Відповідь**:
     - Успіх: `{"message": "Статус замовлення успішно змінено"}`
     - Помилки: HTTP 401, 404, 400, 403.

#### 6. **Видалення посилки**
   - **Метод**: `DELETE /{tracking_number}`
   - **Опис**: Видаляє посилку (тільки відправник може видалити свою посилку).
   - **Перевірки**:
     - Перевірка, чи є у користувача права на видалення посилки.
     - Перевірка наявності посилки за трек-номером.
   - **Відповідь**:
     - Успіх: `{"message": "Замовлення успішно видалено"}`
     - Помилки: HTTP 401, 404, 403.

#### 7. **Отримання статусів посилки**
   - **Метод**: `GET /{shipment_id}/statuses`
   - **Опис**: Повертає історію статусів посилки.
   - **Перевірки**:
     - Перевірка, чи користувач автентифікований.
   - **Відповідь**:
     - Успіх: список статусів посилки.



#### 8. **Отримання інформації про користувача**
   - **Метод**: `GET /me`
   - **Опис**: Повертає деталі поточного користувача. Для доступу потрібно бути автентифікованим.
   - **Перевірки**:
     - Перевірка, чи користувач автентифікований.
   - **Відповідь**:
     - Успіх: інформація про користувача (ім'я, email, телефон тощо).
     - Помилка 401: "Authentication required" (якщо користувач не автентифікований).

#### 9. **Оновлення інформації про користувача**
   - **Метод**: `PUT /me`
   - **Опис**: Дозволяє користувачеві оновити свої дані (наприклад, email, телефон, тощо).
   - **Параметри**:
     - `user_data` (тип `UserUpdateModel`): Дані для оновлення.
   - **Перевірки**:
     - Перевірка, чи користувач автентифікований.
   - **Логіка**:
     - Оновлюються лише ті поля, що були передані в запиті.
   - **Відповідь**:
     - Успіх: оновлена інформація про користувача.
     - Помилка 401: "Authentication required" (якщо користувач не автентифікований).

#### 10. **Отримання списку відділень**
   - **Метод**: `GET /get_branches`
   - **Опис**: Повертає список усіх доступних відділень.
   - **Відповідь**:
     - Успіх: список відділень у форматі JSON.
   - **Логіка**:
     - Виводить усі відділення, зберігаючи інформацію про кожне з них (назва, адреса, контактна інформація і т.д.).
   - **Відповідь**:
     - Успіх: список відділень.

#### Примітки:
- Усі ці функції доступні після логування користувача.
- Користувач може оновлювати лише свої дані, і не має доступу до зміни даних інших користувачів.
- Для отримання інформації про відділення або власні дані, користувач повинен бути автентифікованим.


### Документація до функцій для керування відділеннями (ті, що доступні лише для користувачів з роллю **admin**)

#### 1. **Створення нового відділення**
   - **Метод**: `POST /`
   - **Опис**: Дозволяє створити нове відділення.
   - **Параметри**:
     - `branch_data` (тип `BranchCreate`): Дані для створення нового відділення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка на наявність відділення з такою ж назвою.
   - **Логіка**:
     - Якщо відділення з такою назвою вже існує, повертається помилка.
     - Якщо ім'я унікальне, створюється нове відділення.
   - **Відповідь**:
     - Успіх: дані нового відділення (ID, назва, адреса і т. д.).
     - Помилка 400: "Відділення з такою назвою вже існує".

#### 2. **Отримання списку всіх відділень**
   - **Метод**: `GET /`
   - **Опис**: Повертає список всіх наявних відділень.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
   - **Відповідь**:
     - Успіх: список відділень.
     - Помилка 401: "Авторизація обов'язкова" (якщо користувач не автентифікований).

#### 3. **Отримання конкретного відділення за ID**
   - **Метод**: `GET /{branch_id}`
   - **Опис**: Повертає дані конкретного відділення за його ID.
   - **Параметри**:
     - `branch_id`: ID відділення.
   - **Логіка**:
     - Пошук відділення в базі даних за заданим ID.
     - Якщо відділення не знайдено, повертається помилка.
   - **Відповідь**:
     - Успіх: інформація про відділення (назва, адреса, телефон і т. д.).
     - Помилка 404: "Відділення не знайдено".

#### 4. **Оновлення інформації про відділення**
   - **Метод**: `PUT /{branch_id}`
   - **Опис**: Дозволяє оновити дані відділення.
   - **Параметри**:
     - `branch_id`: ID відділення для оновлення.
     - `branch_data` (тип `BranchCreate`): Дані для оновлення відділення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка, чи існує відділення з таким ID для оновлення.
   - **Логіка**:
     - Якщо відділення не знайдено, повертається помилка.
     - Якщо знайдено, відділення оновлюється згідно з новими даними.
   - **Відповідь**:
     - Успіх: оновлені дані відділення.
     - Помилка 404: "Відділення не знайдено".

#### 5. **Видалення відділення**
   - **Метод**: `DELETE /{branch_id}`
   - **Опис**: Дозволяє видалити відділення за його ID.
   - **Параметри**:
     - `branch_id`: ID відділення для видалення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка на існування відділення з таким ID.
   - **Логіка**:
     - Якщо відділення знайдено, воно видаляється з бази даних.
   - **Відповідь**:
     - Успіх: повідомлення про успішне видалення.
     - Помилка 404: "Відділення не знайдено".

### Примітки:
- Усі ці функції доступні лише для користувачів з роллю "admin". Для цього в кожному запиті виконується перевірка через функцію `check_admin_role`.
- Адміністратор може створювати, оновлювати, отримувати та видаляти відділення пошти.


### Документація до функцій для керування кур'єрами (ті, що доступні лише для користувачів з роллю **admin**)

#### 1. **Створення кур'єра**
   - **Метод**: `POST /`
   - **Опис**: Дозволяє адміністратору створити нового кур'єра на основі існуючого користувача.
   - **Параметри**:
     - `courier_data` (тип `CourierCreate`): Дані для створення нового кур'єра.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка, чи вже існує кур'єр з таким номером телефону.
     - Перевірка, чи користувач має роль "user", щоб його можна було перевести в роль "courier".
   - **Логіка**:
     - Якщо кур'єр з таким номером телефону вже існує, повертається помилка.
     - Якщо користувача з таким ID не знайдено або він вже є кур'єром, повертається помилка.
     - Якщо перевірки пройдено успішно, створюється новий кур'єр, і його роль змінюється на "courier".
   - **Відповідь**:
     - Успіх: дані нового кур'єра.
     - Помилка 400: "Courier with the same phone number already exists".
     - Помилка 404: "User not found".
     - Помилка 400: "Юзер вже працює в компанії".

#### 2. **Отримання списку всіх кур'єрів**
   - **Метод**: `GET /`
   - **Опис**: Повертає список всіх наявних кур'єрів.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
   - **Відповідь**:
     - Успіх: список кур'єрів.
     - Помилка 401: "Authentication required" (якщо користувач не автентифікований).

#### 3. **Отримання конкретного кур'єра за ID**
   - **Метод**: `GET /{courier_id}`
   - **Опис**: Повертає дані конкретного кур'єра за його ID.
   - **Параметри**:
     - `courier_id`: ID кур'єра.
   - **Логіка**:
     - Пошук кур'єра в базі даних за заданим ID.
     - Якщо кур'єр не знайдений, повертається помилка.
   - **Відповідь**:
     - Успіх: інформація про кур'єра (ID, транспорт, активність тощо).
     - Помилка 404: "Courier not found".

#### 4. **Оновлення інформації про кур'єра**
   - **Метод**: `PUT /{courier_id}`
   - **Опис**: Дозволяє адміністратору оновити дані кур'єра.
   - **Параметри**:
     - `courier_id`: ID кур'єра для оновлення.
     - `courier_data` (тип `CourierUpdate`): Дані для оновлення кур'єра.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка, чи існує кур'єр з таким ID для оновлення.
   - **Логіка**:
     - Якщо кур'єр не знайдений, повертається помилка.
     - Якщо знайдений, оновлюється інформація про кур'єра (транспорт, активність, локація).
   - **Відповідь**:
     - Успіх: оновлені дані кур'єра.
     - Помилка 404: "Courier not found".

#### 5. **Видалення кур'єра**
   - **Метод**: `DELETE /{courier_id}`
   - **Опис**: Дозволяє адміністратору видалити кур'єра за його ID.
   - **Параметри**:
     - `courier_id`: ID кур'єра для видалення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка на існування кур'єра з таким ID.
   - **Логіка**:
     - Якщо кур'єр знайдений, видаляється з бази даних, і його роль користувача змінюється на "user".
   - **Відповідь**:
     - Успіх: повідомлення про успішне видалення.
     - Помилка 404: "Courier not found".
     - Помилка 404: "User not found" (якщо не знайдено користувача, який відповідає кур'єру).

### Примітки:
- Усі ці функції доступні лише для користувачів з роллю "admin". Для цього в кожному запиті виконується перевірка через функцію `check_admin_role`.
- Адміністратор може створювати, оновлювати, отримувати та видаляти кур'єрів.



### Документація до функцій для керування маршрутами відправки між відділеннями (ті, що доступні лише для користувачів з роллю **admin**)

#### 1. **Створення нового маршруту**
   - **Метод**: `POST /`
   - **Опис**: Дозволяє адміністратору створити новий маршрут для відправки між відділеннями.
   - **Параметри**:
     - `route_data` (тип `RouteCreate`): Дані для створення нового маршруту.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
   - **Логіка**:
     - Створюється новий маршрут, і дані маршруту зберігаються в базі.
   - **Відповідь**:
     - Успіх: створений маршрут.
   
#### 2. **Отримання списку всіх маршрутів**
   - **Метод**: `GET /`
   - **Опис**: Повертає список всіх наявних маршрутів.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
   - **Відповідь**:
     - Успіх: список маршрутів.

#### 3. **Отримання конкретного маршруту за ID**
   - **Метод**: `GET /{route_id}`
   - **Опис**: Повертає дані конкретного маршруту за його ID.
   - **Параметри**:
     - `route_id`: ID маршруту.
   - **Логіка**:
     - Пошук маршруту в базі даних за заданим ID.
     - Якщо маршрут не знайдений, повертається помилка.
   - **Відповідь**:
     - Успіх: інформація про маршрут.
     - Помилка 404: "Маршрут не знайдено".

#### 4. **Видалення маршруту за ID**
   - **Метод**: `DELETE /{route_id}`
   - **Опис**: Дозволяє адміністратору видалити маршрут за його ID.
   - **Параметри**:
     - `route_id`: ID маршруту для видалення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
   - **Логіка**:
     - Якщо маршрут знайдений, він видаляється з бази даних.
   - **Відповідь**:
     - Успіх: повідомлення про успішне видалення маршруту.
     - Помилка 404: "Маршрут не знайдено".

#### 5. **Створення зв'язку маршруту з відправленням**
   - **Метод**: `POST /route/shipment`
   - **Опис**: Дозволяє адміністратору призначити відправлення до маршруту.
   - **Параметри**:
     - `shipment_data` (тип `RouteShipmentCreate`): Дані для створення зв'язку між маршрутом і відправленням.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка на існування маршруту і відправлення.
     - Перевірка, чи статус відправлення дозволяє додавати його до маршруту.
   - **Логіка**:
     - Якщо відправлення не в статусі "awaiting shipment", то відправлення не може бути додано до маршруту.
     - Якщо маршрут і відправлення існують, створюється зв'язок між ними.
   - **Відповідь**:
     - Успіх: створений зв'язок маршруту і відправлення.
     - Помилка 404: "Маршрут не знайдено" або "Замовлення не знайдено".
     - Помилка 400: "Замовлення не можна додати у доставку, оскільки його статус не є 'awaiting shipment'".

#### 6. **Отримання всіх відправлень для маршруту**
   - **Метод**: `GET /route/{route_id}/shipment`
   - **Опис**: Повертає всі відправлення, пов'язані з заданим маршрутом.
   - **Параметри**:
     - `route_id`: ID маршруту.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
   - **Відповідь**:
     - Успіх: список всіх відправлень, що пов'язані з маршрутом.

#### 7. **Оновлення кур'єра для маршруту**
   - **Метод**: `PUT /route/{route_id}/courier`
   - **Опис**: Дозволяє адміністратору призначити кур'єра на маршрут.
   - **Параметри**:
     - `route_id`: ID маршруту.
     - `courier_id`: ID кур'єра.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка, чи існує маршрут і кур'єр.
     - Перевірка, чи кур'єр уже не має активного маршруту.
   - **Логіка**:
     - Якщо кур'єр уже має активний маршрут, то його не можна призначити на новий.
     - Якщо перевірки пройдено, кур'єр призначається на маршрут.
   - **Відповідь**:
     - Успіх: оновлений маршрут з призначеним кур'єром.
     - Помилка 404: "Маршрут не знайдено".
     - Помилка 400: "Кур'єр вже призначений на інший активний маршрут".

#### 8. **Оновлення статусу маршруту**
   - **Метод**: `PUT /route/{route_id}/status`
   - **Опис**: Дозволяє адміністратору оновити статус маршруту.
   - **Параметри**:
     - `route_id`: ID маршруту.
     - `status`: новий статус маршруту.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка на існування маршруту.
   - **Логіка**:
     - Якщо маршрут знайдений, його статус оновлюється.
   - **Відповідь**:
     - Успіх: оновлений маршрут зі зміненим статусом.
     - Помилка 404: "Маршрут не знайдено".

#### 9. **Видалення зв'язку між маршрутом і відправленням**
   - **Метод**: `DELETE /route/{route_id}/shipment/{shipment_id}`
   - **Опис**: Дозволяє адміністратору видалити зв'язок між маршрутом і відправленням.
   - **Параметри**:
     - `route_id`: ID маршруту.
     - `shipment_id`: ID відправлення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка на існування зв'язку між маршрутом і відправленням.
   - **Логіка**:
     - Якщо зв'язок знайдений, він видаляється з бази даних.
   - **Відповідь**:
     - Успіх: повідомлення про успішне видалення зв'язку.
     - Помилка 404: "Маршрут-відправка не знайдена".

### Примітки:
- Усі ці функції доступні тільки для користувачів з роллю "admin", для цього здійснюється перевірка через функцію `check_admin_role`.
- Ці функції дозволяють адміністратору управляти маршрутами, кур'єрами, статусами і відправленнями в рамках процесу доставки між відділеннями.


### Документація до функцій для керування працівниками поштового відділення (ті, що доступні лише для користувачів з роллю **admin**)

#### 1. **Створення працівника**
   - **Метод**: `POST /`
   - **Опис**: Дозволяє адміністратору створити нового працівника на поштовому відділенні.
   - **Параметри**:
     - `worker` (тип `WorkerCreate`): Дані для створення нового працівника.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором через `check_admin_role`.
     - Перевірка, чи вже існує працівник з таким `user_id`.
     - Перевірка, чи користувач з таким ID існує в системі.
     - Перевірка, чи користувач не має вже ролі працівника.
   - **Логіка**:
     - Якщо перевірки пройдено, створюється запис працівника, роль користувача змінюється на `"worker"`.
   - **Відповідь**:
     - Успіх: створений працівник з усіма даними.
     - Помилка 400: "Працівник з таким ID користувача вже існує".
     - Помилка 404: "User not found".
     - Помилка 400: "Юзер вже працює в компанії".

#### 2. **Отримання списку всіх працівників**
   - **Метод**: `GET /`
   - **Опис**: Повертає список усіх працівників поштового відділення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
   - **Відповідь**:
     - Успіх: список усіх працівників.

#### 3. **Отримання працівника за ID**
   - **Метод**: `GET /{worker_id}`
   - **Опис**: Повертає дані конкретного працівника за його ID.
   - **Параметри**:
     - `worker_id`: ID працівника.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
   - **Логіка**:
     - Якщо працівник знайдений, повертається його інформація.
     - Якщо працівник не знайдений, повертається помилка.
   - **Відповідь**:
     - Успіх: інформація про працівника.
     - Помилка 404: "Працівник не знайдено".

#### 4. **Оновлення даних працівника**
   - **Метод**: `PUT /{worker_id}`
   - **Опис**: Дозволяє адміністратору оновити інформацію про працівника.
   - **Параметри**:
     - `worker_id`: ID працівника.
     - `worker_data` (тип `WorkerUpdate`): Дані для оновлення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка, чи існує працівник з таким ID.
   - **Логіка**:
     - Оновлюється інформація про працівника.
   - **Відповідь**:
     - Успіх: оновлені дані працівника.
     - Помилка 404: "Працівник не знайдено".

#### 5. **Видалення працівника**
   - **Метод**: `DELETE /{worker_id}`
   - **Опис**: Дозволяє адміністратору видалити працівника за його ID.
   - **Параметри**:
     - `worker_id`: ID працівника для видалення.
   - **Перевірки**:
     - Перевірка, чи є користувач адміністратором.
     - Перевірка на існування працівника.
     - Перевірка на існування користувача, який відповідає цьому працівнику.
   - **Логіка**:
     - Якщо працівник знайдений, його зв'язок з користувачем видаляється, і роль користувача змінюється на `"user"`.
   - **Відповідь**:
     - Успіх: повідомлення про успішне видалення працівника.
     - Помилка 404: "Працівник не знайдено".

### Примітки:
- **Обмеження доступу**: Усі ці функції доступні лише для користувачів з роллю **admin**, і перевірка цієї ролі здійснюється через функцію `check_admin_role`.
- **Ключова логіка**:
  - Створення, оновлення та видалення працівників на поштовому відділенні.
  - Всі операції з працівниками включають перевірки для уникнення дублювання та забезпечення коректності даних.


### Документація до функцій для кур'єрів (ті, що доступні тільки для користувачів з роллю **courier**)

#### 1. **Отримання свого активного маршруту**
   - **Метод**: `GET /routes/my`
   - **Опис**: Дозволяє кур'єру отримати інформацію про свій активний маршрут та відправлення, що входять до цього маршруту.
   - **Параметри**:
     - `user` (тип `user_dependency`): Користувач, що виконує запит.
     - `db` (тип `db_dependency`): Підключення до бази даних.
   - **Перевірки**:
     - Перевірка, чи є у користувача роль **courier** (використовує функцію `get_courier`).
     - Перевірка, чи є у кур'єра активний маршрут (використовує функцію `get_active_route`).
   - **Логіка**:
     - Якщо у кур'єра є активний маршрут, повертається детальна інформація про маршрут, відділення та список відправлень.
   - **Відповідь**:
     - Успіх: об'єкт з інформацією про маршрут, відділення та відправлення.
     - Помилка 404: якщо не знайдено активний маршрут для кур'єра.

#### 2. **Старт маршруту**
   - **Метод**: `PUT /routes/{route_id}/start`
   - **Опис**: Дозволяє кур'єру почати виконання маршруту.
   - **Параметри**:
     - `route_id`: ID маршруту.
     - `user` (тип `user_dependency`): Користувач, що виконує запит.
     - `db` (тип `db_dependency`): Підключення до бази даних.
   - **Перевірки**:
     - Перевірка, чи є у користувача роль **courier** (використовує функцію `get_courier`).
     - Перевірка, чи існує активний маршрут для кур'єра (використовує функцію `get_active_route`).
     - Перевірка, чи статус маршруту є `"created"`. Якщо ні, викидається помилка 400.
   - **Логіка**:
     - Якщо статус маршруту `"created"`, змінюється статус маршруту на `"in_transit"`, а також статус всіх відправлень на маршруті змінюється на `"in_transit"`.
     - Всі зміни фіксуються в базі даних.
   - **Відповідь**:
     - Успіх: повідомлення про старт маршруту та зміну статусу відправлень.
     - Помилка 400: "Route must be in 'created' status to start".

#### 3. **Завершення маршруту**
   - **Метод**: `PUT /routes/{route_id}/complete`
   - **Опис**: Дозволяє кур'єру завершити виконання маршруту.
   - **Параметри**:
     - `route_id`: ID маршруту.
     - `user` (тип `user_dependency`): Користувач, що виконує запит.
     - `db` (тип `db_dependency`): Підключення до бази даних.
   - **Перевірки**:
     - Перевірка, чи є у користувача роль **courier** (використовує функцію `get_courier`).
     - Перевірка, чи існує активний маршрут для кур'єра (використовує функцію `get_active_route`).
     - Перевірка, чи статус маршруту є `"in_transit"`. Якщо ні, викидається помилка 400.
   - **Логіка**:
     - Виконується перевірка на отримання всіх відправлень на маршруті за допомогою `check_received_shipments`.
     - Якщо всі відправлення отримано, статус маршруту змінюється на `"completed"`.
   - **Відповідь**:
     - Успіх: повідомлення про завершення маршруту і оновлення статусів відправлень.
     - Помилка 400: "Route must be in 'in_transit' status to complete".

### Примітки:
- **Обмеження доступу**: Всі ці функції доступні лише для користувачів з роллю **courier**, що перевіряється за допомогою функцій **`get_courier`** та **`get_active_route`**.
- **Ключова логіка**:
  - Кур'єр може отримати свій активний маршрут.
  - Кур'єр може почати або завершити маршрут, змінюючи статус маршруту та відправлень відповідно до поточного стану маршруту.


### Документація до функцій для відправників або отримувачів посилок

#### 1. **Створення оплати для посилки**
   - **Метод**: `POST /payment/{shipment_id}`
   - **Опис**: Дозволяє відправнику або отримувачу посилки здійснити оплату за посилку.
   - **Параметри**:
     - `shipment_id`: ID посилки, за яку здійснюється оплата.
     - `payment_data` (тип `PaymentCreate`): Дані про оплату (сума, спосіб оплати).
     - `db` (тип `db_dependency`): Підключення до бази даних.
     - `user` (тип `user_dependency`): Користувач, що виконує запит.
   - **Перевірки**:
     - Перевірка, чи існує посилка з зазначеним ID (використовує запит до моделі `Shipment`).
     - Перевірка, чи вже була здійснена оплата для цієї посилки (використовує функцію `is_shipment_paid`).
     - Перевірка, чи є користувач відправником або отримувачем цієї посилки (використовує функцію `is_sender_or_receiver`).
   - **Логіка**:
     - Якщо посилка знайдена і вона ще не оплачена, створюється запис про оплату.
     - Встановлюється статус оплати посилки на `"paid"`.
     - Оплата зберігається в базі даних.
   - **Відповідь**:
     - Успіх: об'єкт оплати з деталями (сума, метод оплати, статус).
     - Помилка 404: якщо посилка не знайдена.
     - Помилка 400: якщо посилка вже оплачена або користувач не є відправником або отримувачем.

#### 2. **Отримання статусу оплати для посилки**
   - **Метод**: `GET /payment/{shipment_id}`
   - **Опис**: Дозволяє отримати статус оплати для конкретної посилки.
   - **Параметри**:
     - `shipment_id`: ID посилки, для якої потрібно отримати статус оплати.
     - `db` (тип `db_dependency`): Підключення до бази даних.
   - **Перевірки**:
     - Перевірка, чи існує запис про оплату для зазначеної посилки (використовує запит до моделі `Payment`).
   - **Логіка**:
     - Якщо оплата знайдена, повертається інформація про оплату.
     - Якщо оплата не знайдена, викидається помилка 404.
   - **Відповідь**:
     - Успіх: об'єкт оплати з деталями (сума, метод оплати, статус).
     - Помилка 404: якщо оплата не знайдена.

### Примітки:
- **Обмеження доступу**: Тільки **відправник** або **отримувач** цієї посилки можуть здійснити оплату. Це перевіряється за допомогою функції **`is_sender_or_receiver`**.
- **Перевірка статусу оплати**: Перед створенням оплати перевіряється, чи вже була здійснена оплата для посилки за допомогою функції **`is_shipment_paid`**.
- **Робота з даними**:
  - Для кожної посилки ведеться запис про оплату в моделі `Payment`.
  - Кожен запит до цих функцій логірується через `logger` для контролю подій в системі.

Ці функції дозволяють лише відправникам або отримувачам посилок здійснювати оплату та отримувати статус оплати, таким чином обмежуючи доступ до чутливих операцій.

### Документація для функцій, доступних користувачу з роллю `worker` (працівник поштового відділення)

#### 1. **Створення посилки в відділенні**
   - **Метод**: `POST /create_shipment`
   - **Опис**: Створює нову посилку у відділенні, яке вказано у даних працівника.
   - **Параметри**:
     - `shipment_data` (тип `ShipmentCreateAtBranch`): Дані для створення нової посилки, включаючи інформацію про відправника, отримувача та відділення.
     - `db` (тип `db_dependency`): Підключення до бази даних.
     - `user` (тип `user_dependency`): Користувач (працівник), що виконує операцію.
   - **Перевірки**:
     - Перевірка, чи є працівник вказаного відділення.
     - Перевірка, чи відправник і отримувач не є однією особою.
     - Перевірка, чи відділення відправника та отримувача різні.
   - **Логіка**:
     - Створюється унікальний трекінг-номер.
     - Розраховується відстань і ціна доставки на основі координат відділень.
     - Якщо перевірки успішно пройшли, посилка додається в базу даних.
   - **Відповідь**:
     - Успіх: повідомлення про успішне створення посилки та її трекінг-номер.
     - Помилка 400: якщо відділення співпадають або інші дані не вірні.
   
#### 2. **Прийняття посилки на відділення**
   - **Метод**: `PUT /accept_shipment/{tracking_number}`
   - **Опис**: Приймає посилку в поштове відділення, зміщуючи її статус на `"awaiting shipment"`.
   - **Параметри**:
     - `tracking_number`: Трекінг-номер посилки.
     - `db` (тип `db_dependency`): Підключення до бази даних.
     - `user` (тип `user_dependency`): Користувач (працівник), що виконує операцію.
   - **Перевірки**:
     - Перевірка, чи статус посилки дозволяє її прийняття.
     - Перевірка, чи місце відправки та місце прийому посилки збігаються.
   - **Логіка**:
     - Якщо посилка ще не на відділенні, її статус оновлюється на `"awaiting shipment"`.
   - **Відповідь**:
     - Успіх: повідомлення про успішне прийняття посилки.
     - Помилка 400: якщо посилка вже на відділенні або місце відправки не збігається.

#### 3. **Отримання інформації про користувача за штрих-кодом**
   - **Метод**: `GET /user_info_by_barcode/{barcode_id}`
   - **Опис**: Повертає інформацію про користувача (ім'я, телефон, статуси посилок), якщо користувач зареєстрований в системі.
   - **Параметри**:
     - `barcode_id`: Штрих-код користувача.
     - `db` (тип `db_dependency`): Підключення до бази даних.
     - `user` (тип `user_dependency`): Користувач (працівник), що виконує операцію.
   - **Логіка**:
     - Пошук користувача за штрих-кодом та повернення даних про всі його посилки, що ще не були забрані.
   - **Відповідь**:
     - Успіх: інформація про користувача та його активні посилки.
     - Помилка 404: якщо користувач не знайдений.

#### 4. **Прийняття посилки від кур'єра**
   - **Метод**: `PUT /accept_shipment_from_courier/{tracking_number}`
   - **Опис**: Приймає посилку від кур'єра та змінює її статус на `"delivered"`.
   - **Параметри**:
     - `tracking_number`: Трекінг-номер посилки.
     - `db` (тип `db_dependency`): Підключення до бази даних.
     - `user` (тип `user_dependency`): Користувач (працівник), що виконує операцію.
   - **Логіка**:
     - Оновлює статус посилки на `"delivered"` після прийому в відділенні.
   - **Відповідь**:
     - Успіх: повідомлення про успішне прийняття посилки.
     - Помилка 400: якщо посилка не в статусі `"delivered"`.

#### 5. **Оплата посилки**
   - **Метод**: `PUT /pay_shipment/{tracking_number}`
   - **Опис**: Дозволяє оплатити посилку, змінюючи її статус на `"paid"`.
   - **Параметри**:
     - `tracking_number`: Трекінг-номер посилки.
     - `db` (тип `db_dependency`): Підключення до бази даних.
     - `user` (тип `user_dependency`): Користувач (працівник), що виконує операцію.
   - **Перевірки**:
     - Перевірка, чи посилка вже оплачена.
   - **Логіка**:
     - Якщо посилка не оплачена, змінюється її статус на `"paid"`.
   - **Відповідь**:
     - Успіх: повідомлення про успішну оплату.
     - Помилка 400: якщо посилка вже оплачена.

#### 6. **Видача посилки**
   - **Метод**: `PUT /pick_up_shipment/{tracking_number}`
   - **Опис**: Дозволяє забрати посилку з відділення.
   - **Параметри**:
     - `tracking_number`: Трекінг-номер посилки.
     - `db` (тип `db_dependency`): Підключення до бази даних.
     - `user` (тип `user_dependency`): Користувач (працівник), що виконує операцію.
   - **Перевірки**:
     - Перевірка, чи статус посилки дозволяє її забрати.
   - **Логіка**:
     - Якщо посилка знаходиться у статусі `"delivered"`, її статус змінюється на `"picked up"`.
   - **Відповідь**:
     - Успіх: повідомлення про успішну видачу посилки.
     - Помилка 400: якщо посилка не в статусі `"delivered"`.

### Примітки:
- **Обмеження доступу**: Усі ці функції доступні лише користувачам, у яких роль `"worker"`, тобто працівникам поштового відділення.
- **Логування**: Кожен запит, що змінює стан системи, логуються через `logger` для відстеження дій у системі.
- **Перевірка ролі**: Кожна функція, де це необхідно, перевіряє, чи має користувач роль `"worker"`, використовуючи функцію `verify_worker_role`.


### Загальний підсумок документації для API

Це API система для управління посилками та оплатами в поштовому сервісі. Вона забезпечує різні функціональні можливості для трьох основних ролей користувачів: **courier** (кур'єр), **sender/receiver** (відправник/отримувач) та **worker** (працівник поштового відділення). Кожна роль має свої унікальні права доступу до функцій, що відповідають їхньому статусу.

#### Основні функції системи:

1. **Для користувачів з роллю "courier"**:
   - **Отримання маршруту кур'єра**: кур'єр може отримати активний маршрут для доставки посилок та дізнатися, які посилки потрібно доставити.
   - **Початок маршруту**: кур'єр може розпочати маршрут, оновивши статус всіх посилок на "in_transit".
   - **Завершення маршруту**: після завершення маршруту кур'єр оновлює статус маршруту та посилок на "completed", перевіряючи, що всі посилки були отримані.

2. **Для відправників та отримувачів посилок**:
   - **Створення оплати**: тільки відправник або отримувач може ініціювати платіж для посилки, перевіривши її статус і власну роль у доставці.
   - **Отримання статусу оплати**: дозволяє перевірити статус оплати посилки, щоб знати, чи була вона оплачена.

3. **Для працівників поштового відділення**:
   - **Створення посилки**: працівник може створювати нові посилки для відправлення, перевіряючи дані про відділення, відправника та отримувача.
   - **Прийом посилки на відділення**: працівник може приймати посилки до відділення, змінюючи їх статус та місцезнаходження.
   - **Отримання інформації про користувача за штрих-кодом**: дозволяє отримати інформацію про користувача, який зареєстрований у системі, за допомогою штрих-коду.
   - **Прийом посилки від кур'єра**: працівник може прийняти посилку, що доставлена кур'єром, і змінити її статус на "delivered".
   - **Оплата посилки**: працівник може завершити оплату посилки, змінюючи її статус на "paid".
   - **Видача посилки**: після того, як посилка була доставлена, працівник може видавати її отримувачу, змінюючи статус на "picked up".

#### Основні принципи системи:

- **Безпека**: Кожна операція строго перевіряється за допомогою перевірки ролей користувачів. Це гарантує, що лише особи з відповідними правами доступу можуть виконувати конкретні дії (наприклад, тільки працівники можуть створювати або приймати посилки).
- **Логування**: Для кожної дії в системі здійснюється запис в журнал (лог), що дозволяє відслідковувати зміни у системі та забезпечувати прозорість процесів.
- **Валідація даних**: Всі дані, що надходять від користувача (наприклад, дані про посилку або оплату), перевіряються на коректність перед обробкою, що забезпечує правильність виконуваних операцій.

#### Технології та інструменти:

- **FastAPI**: Використовувано для створення API, що дозволяє швидко та ефективно реалізувати серверні функції.
- **SQLAlchemy**: Для роботи з базою даних.
- **Валідація даних**: Параметри API перевіряються за допомогою схеми (pydantic), щоб уникнути помилок при отриманні або відправленні даних.

### Висновок:

Це API дозволяє створювати ефективну систему управління доставкою посилок, забезпечуючи різні рівні доступу для кожної з ролей. Всі операції строго контролюються, а статуси посилок оновлюються в залежності від дій кур'єрів, працівників і користувачів. Кожна роль має чітко визначений набір функцій, що дозволяє здійснювати необхідні дії без перекриття або конфліктів прав доступу.
